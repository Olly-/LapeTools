type TMethod = packed record Method, Self: Pointer; end;
procedure _Assert(Expr: EvalBool); overload; begin end;
procedure _Assert(Expr: EvalBool; Msg: string); overload; begin end;
function GetMem(i: SizeInt): Pointer; begin end;
function AllocMem(i: SizeInt): Pointer; begin end;
procedure FreeMem(p: Pointer); begin end;
procedure ReallocMem(var p: Pointer; s: SizeInt); begin end;
procedure FillMem(var p; s: SizeInt; b: UInt8 = 0); begin end;
procedure Move(constref Src; var Dst; s: SizeInt); begin end;
function CompareMem(constref p1, p2; Length: SizeInt): EvalBool; begin end;
function Assigned(constref p): EvalBool; begin end;
procedure RaiseException(Ex: string); overload; begin end;
procedure UniqueString(var Str: AnsiString); overload; begin end;
procedure UniqueString(var Str: WideString); overload; begin end;
procedure UniqueString(var Str: UnicodeString); overload; begin end;
const Pi: Extended = 3.14159265358979;
var RandSeed: Int32;
function Min(x,y: Int64): Int64; overload; begin end;
function Min(x,y: Extended): Extended; overload; begin end;
function Max(x,y: Int64): Int64; overload; begin end;
function Max(x,y: Extended): Extended; overload; begin end;
function Abs(x: Extended): Extended; overload; begin end;
function Abs(x: Int64): Int64; overload; begin end;
function Sign(AValue: Int64): Int8; overload; begin end;
function Sign(AValue: Extended): Int8; overload; begin end;
function Power(Base, Exponent: Extended): Extended; begin end;
function Sqr(x: Extended): Extended; overload; begin end;
function Sqr(x: Int64): Int64; overload; begin end;
function Sqrt(x: Extended): Extended; begin end;
function ArcTan(x: Extended): Extended; begin end;
function Ln(x: Extended): Extended; begin end;
function Sin(x: Extended): Extended; begin end;
function Cos(x: Extended): Extended; begin end;
function Exp(x: Extended): Extended; begin end;
function Hypot(x,y: Extended): Extended; begin end;
function ArcTan2(x,y: Extended): Extended; begin end;
function Tan(x: Extended): Extended; begin end;
function ArcSin(x: Extended): Extended; begin end;
function ArcCos(x: Extended): Extended; begin end;
function Cotan(x: Extended): Extended; begin end;
function Secant(x: Extended): Extended; begin end;
function Cosecant(x: Extended): Extended; begin end;
function Round(x: Extended): Int64; overload; begin end;
function Round(x: Extended; Precision: Int8): Extended; overload; begin end;
function Frac(x: Extended): Extended; begin end;
function Int(x: Extended): Extended; begin end;
function Trunc(x: Extended): Int64; begin end;
function Ceil(x: Extended): Int64; begin end;
function Floor(x: Extended): Int64; begin end;
function CosH(x: Extended): Extended; begin end;
function SinH(x: Extended): Extended; begin end;
function TanH(x: Extended): Extended; begin end;
function ArcCosH(x: Extended): Extended; begin end;
function ArcSinH(x: Extended): Extended; begin end;
function ArcTanH(x: Extended): Extended; begin end;
function Random(min, max: Int64): Int64; overload; begin end;
function Random(min, max: Extended): Extended; overload; begin end;
function Random(l: Int64): Int64; overload; begin end;
function Random: Extended; overload; begin end;
procedure Randomize; begin end;
type TTextLineBreakStyle = (tlbsLF, tlbsCRLF, tlbsCR);
type TReplaceFlags = set of (rfReplaceAll, rfIgnoreCase);
function UpperCase(s: string): string; begin end;
function LowerCase(s: string): string; begin end;
function UpCase(c: AnsiChar): AnsiChar; overload; begin end;
function UpCase(c: WideChar): WideChar; overload; begin end;
function CompareStr(s1, s2: string): Int32; begin end;
function CompareText(s1, s2: string): Int32; begin end;
function SameText(s1, s2: string): EvalBool; begin end;
function AnsiUpperCase(s: string): string; begin end;
function AnsiLowerCase(s: string): string; begin end;
function AnsiCompareStr(s1, s2: string): Int32; begin end;
function AnsiCompareText(s1, s2: string): Int32; begin end;
function AnsiSameText(s1,s2: string): EvalBool; begin end;
function AnsiSameStr(s1,s2: string): EvalBool; begin end;
function Trim(s: string): string; begin end;
function TrimLeft(s: string): string; begin end;
function TrimRight(s: string): string; begin end;
function PadL(s: string; Len: SizeInt; c: Char = ' '): string; begin end;
function PadR(s: string; Len: SizeInt; c: Char = ' '): string; begin end;
function QuotedStr(s: string): string; begin end;
function AnsiQuotedStr(s: string; Quote: Char): string; begin end;
function AnsiDequotedStr(s: string; AQuote: Char): string; begin end;
function WrapText(Line, BreakStr: string; BreakChars: set of AnsiChar; MaxCol: Int32): string; begin end;
function AdjustLineBreaks(s: string; Style: TTextLineBreakStyle): string; begin end;
function IntToHex(Value: Int64; Digits: Int32 = 1): string; overload; begin end;
function IntToHex(Value: UInt64; Digits: Int32 = 1): string; overload; begin end;
function IntToStr(i: Int64): string; overload; begin end;
function IntToStr(i: UInt64): string; overload; begin end;
function StrToInt(s: string): Int32; begin end;
function StrToIntDef(s: string; Def: Int32): Int32; begin end;
function StrToInt64(s: string): Int64; begin end;
function StrToInt64Def(s: string; Def: Int64): Int64; begin end;
function StrToUInt64(s: string): UInt64; begin end;
function StrToUInt64Def(s: string; Def: UInt64): UInt64; begin end;
function FloatToStr(f: Extended): string; begin end;
function StrToFloat(s: string): Extended; begin end;
function StrToFloatDef(s: string; Def: Extended): Extended; begin end;
function CurrToStr(Value: Currency): string; begin end;
function StrToCurr(s: string): Currency; begin end;
function StrToCurrDef(s: string; Def: Currency): Currency; begin end;
function StrToBool(s: string): EvalBool; begin end;
function BoolToStr(B: EvalBool; TrueS: string = 'True'; FalseS: string = 'False'): string; begin end;
function StrToBoolDef(s: string; Default: EvalBool): EvalBool; begin end;
function Format(Fmt: string; Args: array of Variant): string; begin end;
function FormatFloat(Format: string; Value: Extended): string; begin end;
function FormatCurr(Format: string; Value: Currency): string; begin end;
function LastDelimiter(Delimiters, s: string): SizeInt; begin end;
function StringReplace(S, OldPattern, NewPattern: string; Flags: TReplaceFlags): string; begin end;
Function IsDelimiter(Delimiters, s: string; Index: SizeInt): EvalBool; begin end;
function Pos(Substr: string; Source: string): SizeInt; begin end;
function StringOfChar(c: Char; l: SizeInt): string; begin end;
{$ASSERTIONS ON}{$BOOLEVAL ON}{$CONSTADDRESS ON}{$RANGECHECKS ON}{$AUTOINVOKE OFF}{$AUTOPROPERTIES OFF}{$LOOSESEMICOLON OFF}{$EXTENDEDSYNTAX OFF}{$HINTS OFF}
function Chr(IntValue: UInt8):  AnsiChar; overload; begin Result := AnsiChar(IntValue); end;
function Chr(IntValue: UInt16): WideChar; overload; begin Result := WideChar(IntValue); end;
function EncodeDate(Year, Month, Day: UInt16): TDateTime; begin end;
function EncodeTime(Hour, Min, Sec, MSec: UInt16): TDateTime; begin end;
procedure DecodeDate(DateTime: TDateTime; var Year, Month, Day: UInt16); begin end;
function DecodeDateFully(DateTime: TDateTime; var Year, Month, Day, DOW: UInt16): Boolean; begin end;
procedure DecodeTime(DateTime: TDateTime; var Hour, Min, Sec, MSec: UInt16); begin end;
function DateTimeToStr(const DateTime: TDateTime): string; begin end;
function DateToStr(const DateTime: TDateTime): string; begin end;
function TimeToStr(const DateTime: TDateTime): string; begin end;
function Date: TDateTime; begin end;
function Time: TDateTime; begin end;
function Now: TDateTime; begin end;
function GetTickCount: UInt64; begin end;
procedure Sleep(MilliSeconds: UInt32); begin end;
procedure ReplaceTime(var DateTime: TDateTime; NewTime: TDateTime); begin end;
procedure ReplaceDate(var DateTime: TDateTime; NewDate: TDateTime); begin end;
function FormatDateTime(Format: string; DateTime: TDateTime): string; begin end;
function StrToDate(s: string): TDateTime; begin end;
function StrToDateDef(s: string; Default: TDateTime): TDateTime; begin end;
function StrToTime(s: string): TDateTime; begin end;
function StrToTimeDef(s: string; Default: TDateTime): TDateTime; begin end;
function StrToDateTime(s: string): TDateTime; begin end;
function StrToDateTimeDef(s: string; Default: TDateTime): TDateTime; begin end;
type TVariantRelationship = (vrEqual, vrLessThan, vrGreaterThan, vrNotEqual);
function VarType(const V: Variant): TVarType; begin end;
function VarAsType(const V: Variant; aVarType: TVarType): Variant; begin end;
function VarIsByRef(const V: Variant): EvalBool; begin end;
function VarIsEmpty(const V: Variant): EvalBool; begin end;
function VarIsNull(const V: Variant): EvalBool; begin end;
function VarIsClear(const V: Variant): EvalBool; begin end;
function VarIsError(const V: Variant; out AResult: HRESULT): EvalBool; begin end;
function VarAsError(AResult: HRESULT): Variant; begin end;
function VarIsCustom(const V: Variant): EvalBool; begin end;
function VarIsOrdinal(const V: Variant): EvalBool; begin end;
function VarIsFloat(const V: Variant): EvalBool; begin end;
function VarIsNumeric(const V: Variant): EvalBool; begin end;
function VarIsStr(const V: Variant): EvalBool; begin end;
function VarIsArray(const A: Variant; AResolveByRef: EvalBool = True): EvalBool; begin end;
function VarToStr(const V: Variant): string; begin end;
function VarToStrDef(const V: Variant; ADefault: string): string; begin end;
function VarToWideStr(const V: Variant): WideString; begin end;
function VarToWideStrDef(const V: Variant; ADefault: WideString): WideString; begin end;
function VarToUnicodeStr(const V: Variant): UnicodeString; begin end;
function VarToUnicodeStrDef(const V: Variant; ADefault: UnicodeString): UnicodeString; begin end;
function VarToDateTime(const V: Variant): TDateTime; begin end;
function VarFromDateTime(DateTime: TDateTime): Variant; begin end;
function VarInRange(const AValue, AMin, AMax: Variant): EvalBool; begin end;
function VarEnsureRange(const AValue, AMin, AMax: Variant): Variant; begin end;
function VarSameValue(const A, B: Variant): EvalBool; begin end;
function VarCompareValue(const A, B: Variant): TVariantRelationship; begin end;
function VarTypeIsValidArrayType(aVarType: TVarType): EvalBool; begin end;
function VarTypeIsValidElementType(aVarType: TVarType): EvalBool; begin end;
function VarArrayCreate(Bounds: array of SizeInt; aVarType: TVarType): Variant; begin end;
function VarArrayOf(Values: array of Variant): Variant; begin end;
procedure VarArrayRedim(var A: Variant; HighBound: SizeInt); begin end;
function VarArrayAsPSafeArray(const A: Variant): Pointer; begin end;
procedure VarCopyNoInd(var Dest: Variant; const Source: Variant); begin end;
function VarArrayDimCount(const A: Variant): SizeInt; begin end;
function VarArrayLowBound(const A: Variant; Dim: SizeInt): SizeInt; begin end;
function VarArrayHighBound(const A: Variant; Dim: SizeInt): SizeInt; begin end;
function VarArrayLock(const A: Variant): Pointer; begin end;
procedure VarArrayUnlock(const A: Variant); begin end;
function VarArrayRef(const A: Variant): Variant; begin end;
function VarArrayGet(const A: Variant; Indices: array of Int32): Variant; begin end;
procedure VarArraySet(var A: Variant; const Value: Variant; Indices: array of Int32); begin end;
type TFFI_ABI = (ffi_cdecl=1,ffi_stdcall=2,ffi_thiscall=3,ffi_fastcall=4,ffi_ms_cdecl=5,ffi_pascal=6,ffi_register=7);
const FFI_DEFAULT_ABI: TFFI_ABI = TFFI_ABI(7);
const SharedSuffix: AnsiString = "dll";
function LoadLibrary(const Name: string): TLibHandle; begin end;
function GetProcAddress(Lib: TlibHandle; const ProcName: string): ConstPointer; begin end;
function FreeLibrary(Lib: TLibHandle): EvalBool; begin end;
{$ASSERTIONS ON}{$BOOLEVAL ON}{$CONSTADDRESS ON}{$RANGECHECKS ON}{$AUTOINVOKE OFF}{$AUTOPROPERTIES OFF}{$LOOSESEMICOLON OFF}{$EXTENDEDSYNTAX OFF}{$HINTS OFF}
function StrGet(var s: string; Index: SizeInt): Char; begin Result := s[Index]; end;
function StrGet2(s: string; Index: SizeInt): Char; begin Result := s[Index]; end;
procedure StrSet(c: Char; Index: SizeInt; var s: string); begin s[Index] := c; end;
function WStrGet(var s: WideString; Index: SizeInt): WideChar; begin Result := s[Index]; end;
function VarArrayGet(var s: Variant; Index: Int32): Variant; overload; begin Result := VarArrayGet(s, [Index]); end;
procedure VarArraySet(c: Variant; Index: Int32; var s: Variant); overload; begin VarArraySet(s, c, [Index]); end;
function PadZ(s: string; Len: SizeInt): string; begin Result := PadL(s, Len, '0'); end;
function Replicate(c: Char; l: SizeInt): string; begin Result := StringOfChar(c, l); end;
function Int64ToStr(i: Int64): string; begin Result := IntToStr(i); end;
function UInt64ToStr(i: UInt64): string; begin Result := IntToStr(i); end;
type TIFException = (erNoError, erCannotImport, erInvalidType, erInternalError,erInvalidHeader, erInvalidOpcode, erInvalidOpcodeParameter,erNoMainProc, erOutOfGlobalVarsRange, erOutOfProcRange, erOutOfRange,erOutOfStackRange, erTypeMismatch, erUnexpectedEof, erVersionError,erDivideByZero, erMathError, erCouldNotCallProc, erOutofRecordRange,erOutOfMemory, erException, erNullPointerException, erNullVariantError,erInterfaceNotSupported, erCustomError);
{$ASSERTIONS ON}{$BOOLEVAL ON}{$CONSTADDRESS ON}{$RANGECHECKS ON}{$AUTOINVOKE OFF}{$AUTOPROPERTIES OFF}{$LOOSESEMICOLON OFF}{$EXTENDEDSYNTAX OFF}{$HINTS OFF}
function ExceptionToString(Ex: TIFException; Param: string): string; begin Result := ToString(Ex);if (Param <> '') then Result := Result + '(' + Param + ')';end;
procedure RaiseException(Ex: TIFException; Param: string); overload; begin end;
{$ASSERTIONS ON}{$BOOLEVAL ON}{$CONSTADDRESS ON}{$RANGECHECKS ON}{$AUTOINVOKE OFF}{$AUTOPROPERTIES OFF}{$LOOSESEMICOLON OFF}{$EXTENDEDSYNTAX OFF}{$HINTS OFF}
function GetGlobalPtr(Name: string): ConstPointer;begin Result := nil;end;
function GetGlobalName(Ptr: ConstPointer): string;begin Result := '';end;
function GetGlobal(Name: string): Variant;begin Result := Unassigned;end;
function VariantInvoke(Name: string; Params: array of Variant = []): Variant;const ErrParamCount = 'Parameter count mismatch';var ParamsLen: SizeInt := Length(Params);begin Result := Unassigned;end;
function ToString(constref p: Pointer): string; override;var n: string; begin  Result := inherited();  if (p <> nil) then  begin    n := GetGlobalName(p);    if (n <> '') then Result := '"' + n + '"::' + Result;  end;end;